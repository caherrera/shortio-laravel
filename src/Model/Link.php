<?php

namespace Shortio\Laravel\Model;

use Illuminate\Support\Facades\Cache;
use Shortio\Laravel\Api\ApiInterface;
use Shortio\Laravel\Api\Link as Api;


/**
 * Class Link
 *
 * @package Shortio\Laravel\Model
 *
 * @property string path
 * @property string title
 * @property string icon
 * @property string archived
 * @property string originalURL
 * @property string iphoneURL
 * @property string androidURL
 * @property string splitURL
 * @property string expiresAt
 * @property string expiredURL
 * @property string redirectType
 * @property string cloaking
 * @property string source
 * @property string AutodeletedAt
 * @property integer DomainId
 * @property-read string createdAt
 * @property-read string updatedAt
 * @property-read integer OwnerId
 * @property-read string secureShortURL
 * @property-read string shortURL
 */
class Link extends Model
{

    protected $fillable = Api::properties;

    public static function findByModel($model)
    {
//        return static::findByDomainAndPath($model->domain->hostname, $model->slug);
        return static::all()->filter(
            function ($link) use ($model) {
                return $link->id = $model->shortio_id;
            }
        )->first();
    }

    static public function all()
    {
        $instance = (new static)->newInstance();

        return Cache::remember(
            static::class.'@all',
            config("shortio.cache.timeout"),
            function () use ($instance) {
                $domains = Domain::all();
                $links   = collect();

                foreach ($domains as $domain) {
                    $_links = $instance->where(['domain_id' => $domain->id])->get();
                    $links  = $links->merge($_links);
                }

                return $links->all();
            }
        );
    }

    public function get($path = null)
    {
        $result = parent::get($path); // TODO: Change the autogenerated stub

        return is_array($result) && isset($result['links']) ? $this->hydrate($result['links']) : $this->hydrate([$result]);
    }

    public static function findByDomainAndPath($domain, $path)
    {
        return static::all()->filter(
            function ($link) use ($domain, $path) {
                return $link->path === $path && $domain === $link->domain->hostname;
            }
        );
//        $instance = (new static)->newInstance();
//        $instance->where("domain", $domain)->where('path', $path);
//        if ($items = $instance->get('expand')) {
//            return $instance->hydrate($items->all());
//        } else {
//            return collect();
//        }
    }


    public function domain()
    {
        if ( ! $this->domain) {
            if ($this->DomainId) {
                return $this->domain = Domain::find($this->DomainId);
            }
        }

        return $this->domain;
    }

    /**
     * Perform a model insert operation.
     *
     * @return bool
     */
    protected function performInsert(ApiInterface $api)
    {
        if ($this->fireModelEvent('creating') === false) {
            return false;
        }

        $attributes = collect($this->getAttributes())->filter(
            function ($v) {
                return ! empty($v);
            }
        )->all();
        if (isset($attributes['DomainId'])) {
            $attributes['domain'] = Domain::find($attributes['DomainId'])->hostname;
            unset($attributes['DomainId']);
        }

        if (empty($attributes)) {
            return true;
        }

        $data = $api->save($attributes);
        $this->fill($data);

        // We will go ahead and set the exists property to true, so that it is set when
        // the created event is fired, just in case the developer tries to update it
        // during the event. This will allow them to do so and run an update here.
        $this->exists = true;

        $this->wasRecentlyCreated = true;

        $this->fireModelEvent('created', false);

        return true;
    }

}
